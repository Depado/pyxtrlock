#!/usr/bin/env python3
# emacs this is -*-python-*-

import sys
import time
from ctypes import byref, pointer, POINTER
from ctypes import c_int, c_uint32

import xcb

lock_width = 28
lock_height = 40
lock_x_hot = 14
lock_y_hot = 21
lock_bits = bytes([
    0xff, 0xff, 0xff, 0xff, 0xff, 0x01, 0xf8, 0xff, 0x7f, 0x00, 0xe0, 0xff,
    0x3f, 0x00, 0xc0, 0xff, 0x1f, 0x00, 0x80, 0xff, 0x0f, 0xfc, 0x03, 0xff,
    0x0f, 0xfe, 0x07, 0xff, 0x0f, 0xff, 0x0f, 0xff, 0x07, 0xff, 0x0f, 0xfe,
    0x87, 0xff, 0x1f, 0xfe, 0x87, 0xff, 0x1f, 0xfe, 0x87, 0xff, 0x1f, 0xfe,
    0x87, 0xff, 0x1f, 0xfe, 0x87, 0xff, 0x1f, 0xfe, 0x87, 0xff, 0x1f, 0xfe,
    0x87, 0xff, 0x1f, 0xfe, 0x87, 0xff, 0x1f, 0xfe, 0x87, 0xff, 0x1f, 0xfe,
    0x87, 0xff, 0x1f, 0xfe, 0x01, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 0xf8,
    0x01, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 0xf8, 0x01, 0xf0, 0x00, 0xf8,
    0x01, 0xf8, 0x01, 0xf8, 0x01, 0xf8, 0x01, 0xf8, 0x01, 0xf8, 0x01, 0xf8,
    0x01, 0xf8, 0x01, 0xf8, 0x01, 0xf0, 0x00, 0xf8, 0x01, 0x60, 0x00, 0xf8,
    0x01, 0x60, 0x00, 0xf8, 0x01, 0x60, 0x00, 0xf8, 0x01, 0x60, 0x00, 0xf8,
    0x01, 0x60, 0x00, 0xf8, 0x01, 0x60, 0x00, 0xf8, 0x01, 0x00, 0x00, 0xf8,
    0x01, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 0xf8,
    0xff, 0xff, 0xff, 0xff
])

mask_width = 28
mask_height = 40
mask_x_hot = 14
mask_y_hot = 21
mask_bits = bytes([
    0x00, 0xfe, 0x07, 0x00, 0x80, 0xff, 0x1f, 0x00, 0xc0, 0xff, 0x3f, 0x00,
    0xe0, 0xff, 0x7f, 0x00, 0xf0, 0xff, 0xff, 0x00, 0xf8, 0xff, 0xff, 0x01,
    0xf8, 0x03, 0xfc, 0x01, 0xf8, 0x01, 0xf8, 0x01, 0xfc, 0x01, 0xf8, 0x03,
    0xfc, 0x00, 0xf0, 0x03, 0xfc, 0x00, 0xf0, 0x03, 0xfc, 0x00, 0xf0, 0x03,
    0xfc, 0x00, 0xf0, 0x03, 0xfc, 0x00, 0xf0, 0x03, 0xfc, 0x00, 0xf0, 0x03,
    0xfc, 0x00, 0xf0, 0x03, 0xfc, 0x00, 0xf0, 0x03, 0xfc, 0x00, 0xf0, 0x03,
    0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f,
    0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f,
    0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f,
    0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f,
    0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f,
    0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f,
    0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f, 0xff, 0xff, 0xff, 0x0f,
    0xff, 0xff, 0xff, 0x0f
])


screen_num = c_int()

conn = xcb.connect(None, byref(screen_num))

# TODO if !conn...

print('screen {}'.format(screen_num.value))

setup = xcb.get_setup(conn)

iter_ = xcb.setup_roots_iterator(setup)

while screen_num.value:
    xcb.screen_next(byref(iter_))
    screen_num.value -= 1

screen = iter_.data.contents

# create window
window = xcb.generate_id(conn)

ret = xcb.create_window(conn, xcb.COPY_FROM_PARENT, window, screen.root,
                        0, 0, 100, 100, 0, xcb.WINDOW_CLASS_INPUT_ONLY,
                        xcb.VisualID(xcb.COPY_FROM_PARENT),
                        xcb.CW_OVERRIDE_REDIRECT,
                        byref(c_uint32(1)))

# select input
input_mask = xcb.EVENT_MASK_KEY_PRESS | xcb.EVENT_MASK_RELEASE_PRESS
xcb.screensaver_select_input(conn, window, input_mask)

print("window id {} hex {}".format(window.value, hex(window.value)))

# create cursor
csr_map = xcb.image_create_pixmap_from_bitmap_data(conn, window, lock_bits,
                                                   lock_width, lock_height,
                                                   1, 0, 0, None)
csr_mask = xcb.image_create_pixmap_from_bitmap_data(conn, window, mask_bits,
                                                    mask_width, mask_height,
                                                    1, 0, 0, None)

csr_bg = xcb.alloc_named_color_sync(conn, screen.default_colormap,
                                    "steelblue3").contents
csr_fg = xcb.alloc_named_color_sync(conn, screen.default_colormap,
                                    "grey25").contents

try:
    cursor = xcb.create_cursor_sync(conn, csr_map, csr_mask, csr_fg, csr_bg,
                                    lock_x_hot, lock_y_hot)
except xcb.XCBError as e:
    print("pyxtrlock: Could not create cursor", file=sys.stderr)
    sys.exit(1)

# map window
xcb.map_window(conn, window)

# Grab keyboard
try:
    kbd_grab = xcb.grab_keyboard_sync(conn, 0, window, xcb.CURRENT_TIME,
                                      xcb.GRAB_MODE_ASYNC, xcb.GRAB_MODE_ASYNC)
except xcb.XCBError as e:
    print("pyxtrlock: Could not get grab keyboard", file=sys.stderr)
    sys.exit(1)

# Grab pointer
# Use the method from the original xtrlock code:
#  "Sometimes the WM doesn't ungrab the keyboard quickly enough if
#  launching xtrlock from a keystroke shortcut, meaning xtrlock fails
#  to start We deal with this by waiting (up to 100 times) for 10,000
#  microsecs and trying to grab each time. If we still fail
#  (i.e. after 1s in total), then give up, and emit an error"
for i in range(100):
    try:
        ptr_grab = xcb.grab_pointer_sync(conn, False, window, 0,
                                         xcb.GRAB_MODE_ASYNC,
                                         xcb.GRAB_MODE_ASYNC,
                                         xcb.WINDOW_NONE, cursor,
                                         xcb.CURRENT_TIME)
        break
    except xcb.XCBError as e:
        time.sleep(0.01)
else:
    print("pyxtrlock: Could not grab pointing device", file=sys.stderr)
    sys.exit(1)

xcb.flush(conn)

#print("named color:", named_color)
#for i in named_color.contents._fields_:
#    print("  {} = {}".format(i[0], getattr(named_color.contents, i[0])))

time.sleep(10)

xcb.disconnect(conn)
